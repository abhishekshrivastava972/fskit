        -:    0:Source:/Users/logan/Projects/FSKit/Source/FSKLoginController.m
        -:    0:Graph:/Users/logan/Projects/builds/FSKit.build/Coverage/FSKit.build/Objects-normal/ppc/FSKLoginController.gcno
        -:    0:Data:/Users/logan/Projects/builds/FSKit.build/Coverage/FSKit.build/Objects-normal/ppc/FSKLoginController.gcda
        -:    0:Runs:6
        -:    0:Programs:1
        -:    1://
        -:    2://  FSKLoginController.m
        -:    3://  FSKit
        -:    4://
        -:    5://  Created by Logan Allred on 1/24/08.
        -:    6://  Copyright 2008 Logan Allred. All rights reserved.
        -:    7://
        -:    8:
        -:    9:// The controller can either limit it's scope to providing a username/password credential, or it
        -:   10:// can handle the entier authentication challenge. We'll see if it can handle both
        -:   11:
        -:   12:#import "FSKLoginController.h"
        -:   13:#import "FSKConnection.h"
        -:   14:
        -:   15:#define LoginPanelNibName @"LoginPanel"
        -:   16:
        -:   17:
        -:   18:static NSString *ERR_LOGIN_AUTHENTICATION = @"Invalid sign-in name or password";
        -:   19:static NSString *ERR_LOGIN_OTHER = @"Login Error.";
        -:   20:static NSString *ERR_LOGIN_NO_CREDENTIALS_SPECIFIED = @"Sign-in name or password not specified";
        -:   21:
        -:   22://static NSString *kUSERNAME_DEFAULTS_KEY = @"username";
        -:   23://static NSString *kPASSWORD_DEFAULTS_KEY = @"password";
        -:   24://static NSString *kAPI_URL_DEFAULTS_KEY = @"apiurl";
        -:   25://static NSString *kAUTOLOGIN_DEFAULTS_KEY = @"autologin";
        -:   26:static NSString *kREGISTRATION_URL = @"https://new.familysearch.org/";  // TODO, fix this once registration is available
        -:   27:
        -:   28:static NSString *kDEFAULT_SECURITY_DOMAIN = @"FamilySearch API, Version 1.0"; // TODO get this from the challenge
        -:   29:
        -:   30:
        -:   31:@implementation FSKLoginController
        -:   32:- (id)init
    #####:   33:{
    #####:   34:    self = [super initWithWindowNibName:@"LoginDialog"];
        -:   35:    
        -:   36:    if ( self ) {
        -:   37://		_request = [request retain];
        -:   38://		loginProperties = [[NSMutableDictionary alloc] init];
        -:   39:	}
    #####:   40:    return self;
        -:   41:}
        -:   42:
        -:   43:- (void)dealloc
    #####:   44:{
        -:   45://	[loginProperties release];
        -:   46://	[_request release];
    #####:   47:    [super dealloc];
        -:   48:}
        -:   49:
        -:   50://- (IBAction)login:(id)sender {
        -:   51://	NSURLCredential *credential = [NSURLCredential credentialWithUser:[signInNameField stringValue] password:[passwordField stringValue] persistence:nil];
        -:   52://	//[NSApp endSheet:[self window]];
        -:   53://}
        -:   54:
    #####:   55:- (IBAction)cancel:(id)sender {
        -:   56:    // This is required because the body of this method is going to
        -:   57:    // remove all of the panel's remaining refs, which can cause a
        -:   58:    // crash later when finishing button hit tracking.  So we make
        -:   59:    // sure it lives on a bit longer.
    #####:   60:    [[loginPanel retain] autorelease];
        -:   61:    
        -:   62:    // This is required as a workaround for AppKit issue 4118422
    #####:   63:    [[self retain] autorelease];
        -:   64:
    #####:   65:    [loginPanel close];
    #####:   66:    if (usingSheet) {
    #####:   67:        [[NSApplication sharedApplication] endSheet:loginPanel returnCode:1];
        -:   68:    } else {
    #####:   69:        [[NSApplication sharedApplication] stopModalWithCode:1];
        -:   70:    }
        -:   71:
        -:   72:}
        -:   73:    /*
        -:   74:- (void) login {
        -:   75:    NSDictionary *values = [[NSUserDefaultsController sharedUserDefaultsController] values];
        -:   76:    NSString *user = [values valueForKey: kUSERNAME_DEFAULTS_KEY];
        -:   77:    NSString *apiURLString = [values valueForKey: kAPI_URL_DEFAULTS_KEY];
        -:   78:	NSURL *apiURL = [NSURL URLWithString: FSAPIServerUrlString];
        -:   79:	NSError *loginError;
        -:   80:
        -:   81:	BOOL autologin = NO;//[[values valueForKey: kAUTOLOGIN_DEFAULTS_KEY] boolValue];
        -:   82:
        -:   83:	if (user) {
        -:   84://		[loginProperties setObject: user forKey: kUSERNAME_DEFAULTS_KEY];
        -:   85:
        -:   86:		NSString *password = [SFHFKeychainUtils getWebPasswordForUser: user URL: apiURL domain: kDEFAULT_SECURITY_DOMAIN itemReference: NULL];
        -:   87:				
        -:   88:		if (password) {
        -:   89:			if (autologin) {
        -:   90:				if ([self loginWithUsername: user password: password APIURL: apiURL error: &loginError])
        -:   91:					return;
        -:   92:				else if([loginError code] == -1012)
        -:   93:					[loginErrorText setStringValue: ERR_LOGIN_AUTHENTICATION];
        -:   94:				else 
        -:   95:					[loginErrorText setStringValue: ERR_LOGIN_OTHER];
        -:   96:			}
        -:   97://			[loginProperties setObject: password forKey: kPASSWORD_DEFAULTS_KEY];
        -:   98:		}
        -:   99:	}
        -:  100:	
        -:  101://	[loginProperties setObject: [NSNumber numberWithBool: autologin] forKey: @"autologin"];
        -:  102:	
        -:  103:	NSLog(@"main window: %@", [NSApp mainWindow]);
        -:  104:	NSLog(@"self window: %@", [self window]);
        -:  105:	NSLog(@"login panel: %@", loginPanel);
        -:  106:	[NSApp beginSheet:[self window]
        -:  107:		modalForWindow:nil
        -:  108:		 modalDelegate:self
        -:  109:		didEndSelector:@selector(loginSheetFinished:)
        -:  110:		 contextInfo:nil];
        -:  111://	[loginPanel makeKeyAndOrderFront: self];
        -:  112:}
        -:  113:*/
        -:  114:
    #####:  115:- (IBAction) loginFromPanel: (id) sender {
    #####:  116:	[loginErrorText setStringValue: @""];
    #####:  117:	[loginErrorText display];
    #####:  118:	[spinner startAnimation: self];
        -:  119:	//[self commitEditing];
        -:  120:
    #####:  121:	NSString *username = [signInNameField stringValue];//[loginProperties objectForKey: kUSERNAME_DEFAULTS_KEY];
    #####:  122:	NSString *password = [passwordField stringValue];//[loginProperties objectForKey: kPASSWORD_DEFAULTS_KEY];
        -:  123://	BOOL autologin = [[loginProperties objectForKey: @"autologin"] boolValue];
        -:  124:	NSError *loginError;
        -:  125:
    #####:  126:	if (!username || !password || [username length] == 0 || [password length] == 0) {
    #####:  127:		[loginErrorText setStringValue: ERR_LOGIN_NO_CREDENTIALS_SPECIFIED];
    #####:  128:		[spinner stopAnimation: self];
    #####:  129:		return;
        -:  130:	}
        -:  131:	
        -:  132://from webkit
        -:  133:    // This is required because the body of this method is going to
        -:  134:    // remove all of the panel's remaining refs, which can cause a
        -:  135:    // crash later when finishing button hit tracking.  So we make
        -:  136:    // sure it lives on a bit longer.
    #####:  137:    [[loginPanel retain] autorelease];
        -:  138:
    #####:  139:    [loginPanel close];
    #####:  140:    if (usingSheet) {
    #####:  141:        [[NSApplication sharedApplication] endSheet:loginPanel returnCode:0];
        -:  142:    } else {
    #####:  143:        [[NSApplication sharedApplication] stopModalWithCode:0];
        -:  144:    }
        -:  145:
        -:  146://    NSDictionary *values = [[NSUserDefaultsController sharedUserDefaultsController] values];	
        -:  147://    NSString *apiURLString = [values valueForKey: kAPI_URL_DEFAULTS_KEY];
    #####:  148:	NSURL *apiURL = [NSURL URLWithString: FSAPIServerUrlString];	
        -:  149:	
        -:  150:	/* Write username to defaults */
        -:  151://	NSUserDefaults *defaults = [[NSUserDefaultsController sharedUserDefaultsController] defaults];
        -:  152://	[defaults setObject: username forKey: kUSERNAME_DEFAULTS_KEY];
        -:  153:	
        -:  154:	/* If we're supposed to autologin, remember that */
        -:  155://	[defaults setObject: [NSNumber numberWithBool: autologin] forKey: kAUTOLOGIN_DEFAULTS_KEY];
        -:  156:		
        -:  157:	/* Make sure the password gets updated in both the keychain and the shared NSURLCredentialStorage used by NSURLConnection */
        -:  158://	NSURLCredential *credential = [NSURLCredential credentialWithUser: username password: password persistence: NSURLCredentialPersistenceForSession];
        -:  159://	NSURLProtectionSpace *protectionSpace = [[NSURLProtectionSpace alloc] initWithHost: [apiURL host] port: 0 protocol: [apiURL scheme] realm: kDEFAULT_SECURITY_DOMAIN authenticationMethod: NSURLAuthenticationMethodDefault];
        -:  160://	NSLog(@"b4 def cred: %@", [[NSURLCredentialStorage sharedCredentialStorage] defaultCredentialForProtectionSpace: protectionSpace]);
        -:  161://	NSLog(@"b4 all creds: %@", [[NSURLCredentialStorage sharedCredentialStorage] credentialsForProtectionSpace: protectionSpace]);
        -:  162://	[[NSURLCredentialStorage sharedCredentialStorage] setDefaultCredential: credential forProtectionSpace: protectionSpace];
        -:  163://	NSLog(@"af def cred: %@", [[NSURLCredentialStorage sharedCredentialStorage] defaultCredentialForProtectionSpace: protectionSpace]);
        -:  164://	NSLog(@"af all creds: %@", [[NSURLCredentialStorage sharedCredentialStorage] credentialsForProtectionSpace: protectionSpace]);
        -:  165:	
        -:  166://	if([self loginWithUsername: username password: password APIURL: apiURL error: &loginError]) {
        -:  167://		[loginPanel close];
        -:  168://	}
        -:  169://	else {
        -:  170://		if([loginError code] == -1012)
        -:  171://			[loginErrorText setStringValue: ERR_LOGIN_AUTHENTICATION];
        -:  172://		else
        -:  173://			[loginErrorText setStringValue: ERR_LOGIN_OTHER];
        -:  174://	}
        -:  175:	
    #####:  176:	[spinner stopAnimation: self];
        -:  177:}
        -:  178:
    #####:  179:- (IBAction) cancelLogin: (id) sender {
    #####:  180:    [[NSUserDefaultsController sharedUserDefaultsController] revert: self];
    #####:  181:    [self cancel:sender];
        -:  182:}
        -:  183:
    #####:  184:- (IBAction) openRegistrationURL: (id) sender {
    #####:  185:    [[NSWorkspace sharedWorkspace] openURL: [NSURL URLWithString: kREGISTRATION_URL]];
        -:  186:}
        -:  187:
        -:  188:
        -:  189:-(void)startAuthentication:(NSURLAuthenticationChallenge *)challenge window:(NSWindow *)w
    #####:  190:{
    #####:  191:	NSLog(@"%s %@", __PRETTY_FUNCTION__, [challenge protectionSpace]);
    #####:  192:	NSLog(@"%s host:%@ realm:%@", __PRETTY_FUNCTION__, [[challenge protectionSpace] host], [[challenge protectionSpace] realm]);
    #####:  193:	NSLog(@"%s %@", __PRETTY_FUNCTION__, [[NSURLCredentialStorage sharedCredentialStorage] credentialsForProtectionSpace:[challenge protectionSpace]]);
    #####:  194:	NSLog(@"%s %@", __PRETTY_FUNCTION__, [[NSURLCredentialStorage sharedCredentialStorage] defaultCredentialForProtectionSpace:[challenge protectionSpace]]);
        -:  195:
    #####:  196:	NSURLCredential *latestCredential = [[NSURLCredentialStorage sharedCredentialStorage] defaultCredentialForProtectionSpace:[challenge protectionSpace]];
    #####:  197:	NSLog(@"latestCredential: %@ hasPwd: %d", latestCredential, [latestCredential hasPassword]);
        -:  198:	
    #####:  199:    if ([latestCredential hasPassword]) {
    #####:  200:        [[challenge sender] useCredential:latestCredential forAuthenticationChallenge:challenge];
    #####:  201:        [challenge release];
    #####:  202:        return;
        -:  203:    }
        -:  204:                                                                    
        -:  205://    [self startAuthentication:challenge window:(window == WebModalDialogPretendWindow ? nil : window)];
        -:  206:    //[challenge release];
        -:  207:
        -:  208:
    #####:  209:    id window = w;// ? (id)w : (id)WebModalDialogPretendWindow;
        -:  210:
        -:  211:    // In this case, we have an attached sheet that's not one of our
        -:  212:    // authentication panels, so enqueing is not an option. Just
        -:  213:    // cancel authentication instead, since this case is fairly
        -:  214:    // unlikely (how would you be loading a page if you had an error
        -:  215:    // sheet up?)
    #####:  216:    if ([w attachedSheet] != nil) {
    #####:  217:        [[challenge sender] cancelAuthenticationChallenge:challenge];
    #####:  218:        return;
        -:  219:    }
        -:  220:
        -:  221:    
    #####:  222:    if (window) {
    #####:  223:        [self runAsSheetOnWindow:window withChallenge:challenge];
        -:  224:    } else {
    #####:  225:        [self runAsModalDialogWithChallenge:challenge];
        -:  226:    }
        -:  227:}
        -:  228:
        -:  229:-(void)cancelAuthentication:(NSURLAuthenticationChallenge *)challenge
    #####:  230:{
    #####:  231:	[loginPanel cancelOperation:self];
        -:  232:}
        -:  233:
        -:  234:-(void)_authenticationDoneWithChallenge:(NSURLAuthenticationChallenge *)challenge result:(NSURLCredential *)credential
    #####:  235:{
    #####:  236:	NSLog(@"%s %@ %@", __PRETTY_FUNCTION__, challenge, credential);
        -:  237:
    #####:  238:    if (credential == nil) {
    #####:  239:        [[challenge sender] cancelAuthenticationChallenge:challenge];
        -:  240:    } else {
    #####:  241:        [[challenge sender] useCredential:credential forAuthenticationChallenge:challenge];
        -:  242:    }
        -:  243:
        -:  244:}
        -:  245:
        -:  246:
        -:  247:- (BOOL)loadNib
    #####:  248:{
    #####:  249:	NSLog(@"%s", __PRETTY_FUNCTION__);
        -:  250:	
    #####:  251:    if (!nibLoaded) {
    #####:  252:        if ([NSBundle loadNibNamed:LoginPanelNibName owner:self]) {
    #####:  253:            nibLoaded = YES;
    #####:  254:            [imageView setImage:[NSImage imageNamed:@"NSApplicationIcon"]];
        -:  255:        } else {
    #####:  256:           NSLog(@"couldn't load nib named '%@'", LoginPanelNibName);
    #####:  257:            return FALSE;
        -:  258:        }
        -:  259:    }
    #####:  260:    return TRUE;
        -:  261:}
        -:  262:
        -:  263:// Methods related to displaying the panel
        -:  264:
        -:  265:-(void)setUpForChallenge:(NSURLAuthenticationChallenge *)chall
    #####:  266:{
    #####:  267:    [self loadNib];
        -:  268:
    #####:  269:    NSURLProtectionSpace *space = [chall protectionSpace];
        -:  270:
        -:  271:    NSString *host;
    #####:  272:    if ([space port] == 0) {
    #####:  273:        host = [space host];
        -:  274:    } else {
    #####:  275:        host = [NSString stringWithFormat:@"%@:%u", [space host], [space port]];
        -:  276:    }
        -:  277:
        -:  278: //   NSString *realm = [space realm];
    #####:  279:    NSString *message = @"";
        -:  280:
    #####:  281:    if ([chall previousFailureCount] > 0) {
    #####:  282:            message = @"The sign-in name or password was incorrect. Please try again.";
        -:  283:    }
        -:  284:
    #####:  285:    [loginErrorText setStringValue:message];
        -:  286:    //[mainLabel sizeToFitAndAdjustWindowHeight];
        -:  287:
        -:  288://    if ([space receivesCredentialSecurely]) {
        -:  289://        [smallLabel setStringValue:
        -:  290://            @"Your log-in information will be sent securely."];
        -:  291://    } else {
        -:  292://        [smallLabel setStringValue:
        -:  293://            @"Your password will be sent in the clear."];
        -:  294://    }
        -:  295:
    #####:  296:    if ([[chall proposedCredential] user] != nil) {
    #####:  297:        [signInNameField setStringValue:[[chall proposedCredential] user]];
    #####:  298:        [loginPanel setInitialFirstResponder:passwordField];
        -:  299:    } else {
    #####:  300:        [signInNameField setStringValue:@""];
    #####:  301:        [passwordField setStringValue:@""];
    #####:  302:        [loginPanel setInitialFirstResponder:signInNameField];
        -:  303:    }
        -:  304:}
        -:  305:
        -:  306:- (void)runAsModalDialogWithChallenge:(NSURLAuthenticationChallenge *)chall
    #####:  307:{
    #####:  308:    [self setUpForChallenge:chall];
    #####:  309:    usingSheet = FALSE;
    #####:  310:    NSURLCredential *credential = nil;
        -:  311:
    #####:  312:    if ([[NSApplication sharedApplication] runModalForWindow:loginPanel] == 0) {
    #####:  313:        credential = [NSURLCredential credentialWithUser:[signInNameField stringValue] password:[passwordField stringValue] persistence:([remember state] == NSOnState) ? NSURLCredentialPersistenceForSession : NSURLCredentialPersistenceForSession];
        -:  314:    }
        -:  315:
    #####:  316:	[[chall sender] useCredential:credential forAuthenticationChallenge:chall];
        -:  317://    [callback performSelector:selector withObject:chall withObject:credential];
        -:  318:}
        -:  319:
        -:  320:- (void)runAsSheetOnWindow:(NSWindow *)window withChallenge:(NSURLAuthenticationChallenge *)chall
    #####:  321:{
        -:  322:    //ASSERT(!usingSheet);
        -:  323:
    #####:  324:    [self setUpForChallenge:chall];
        -:  325:
    #####:  326:    usingSheet = TRUE;
    #####:  327:    _challenge = [chall retain];
        -:  328:    
    #####:  329:    [[NSApplication sharedApplication] beginSheet:loginPanel modalForWindow:window modalDelegate:self didEndSelector:@selector(sheetDidEnd:returnCode:contextInfo:) contextInfo:NULL];
        -:  330:}
        -:  331:
        -:  332:- (void)sheetDidEnd:(NSWindow *)sheet returnCode:(int)returnCode contextInfo:(void  *)contextInfo
    #####:  333:{
    #####:  334:    NSURLCredential *credential = nil;
        -:  335:    NSURLAuthenticationChallenge *chall;
        -:  336:
        -:  337:    //ASSERT(usingSheet);
        -:  338:    //ASSERT(challenge1 != nil);
        -:  339:
    #####:  340:    if (returnCode == 0) {
    #####:  341:        credential = [NSURLCredential credentialWithUser:[signInNameField stringValue] password:[passwordField stringValue] persistence:([remember state] == NSOnState) ? NSURLCredentialPersistenceForSession : NSURLCredentialPersistenceForSession];
        -:  342:    }
        -:  343:
        -:  344:    // We take this tricky approach to nilling out and releasing the challenge
        -:  345:    // because the callback below might remove our last ref.
    #####:  346:    chall = _challenge;
    #####:  347:    _challenge = nil;
    #####:  348:	[[chall sender] useCredential:credential forAuthenticationChallenge:chall];
        -:  349://    [callback performSelector:selector withObject:chall withObject:credential];
    #####:  350:    [chall release];
        -:  351:}
        -:  352:
        -:  353:@end
        -:  354:
        -:  355:/*
        -:  356:	NSProgressIndicator subclass that hides itself when it's empty (not indeterminate, and a value of 0.0)
        -:  357:	Original Source: <http://cocoa.karelia.com/AppKit_Classes/NSProgressIndicator_.m>
        -:  358:	(See copyright notice at <http://cocoa.karelia.com>)
        -:  359:*/
        -:  360:/*
        -:  361:@interface HidingProgress : NSProgressIndicator
        -:  362:
        -:  363:- (void)drawRect:(NSRect)aRect;
        -:  364:
        -:  365:@end
        -:  366:
        -:  367:@implementation HidingProgress
        -:  368:
        -:  369:- (void)drawRect:(NSRect)aRect
        -:  370:{
        -:  371:	if ([self isIndeterminate] || [self doubleValue] > 0.0)
        -:  372:	{
        -:  373:		[super drawRect:aRect];
        -:  374:	}
        -:  375:}
        -:  376:
        -:  377:@end
        -:  378:*/