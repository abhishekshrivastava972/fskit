        -:    0:Source:/Users/logan/Projects/FSKit/Source/FSKConnection.m
        -:    0:Graph:/Users/logan/Projects/builds/FSKit.build/Coverage/FSKit.build/Objects-normal/ppc/FSKConnection.gcno
        -:    0:Data:/Users/logan/Projects/builds/FSKit.build/Coverage/FSKit.build/Objects-normal/ppc/FSKConnection.gcda
        -:    0:Runs:6
        -:    0:Programs:1
        -:    1://
        -:    2://  FamilySearchConnection.m
        -:    3://  FSKit
        -:    4://
        -:    5://  Created by Logan Allred on 6/9/07.
        -:    6://  Copyright 2008 Logan Allred. All rights reserved.
        -:    7://
        -:    8:
        -:    9:#import "FSKConnection.h"
        -:   10:
        -:   11://NSString *FSAPIServerUrlString = @"https://api.familysearch.org/";  // Production
        -:   12:NSString *FSAPIServerUrlString = @"https://apibeta.familysearch.org/";  // Beta
        -:   13://NSString *FSAPIServerUrlString = @"http://www.dev.usys.org/";  // Development
        -:   14:NSString *FSAPIVersion = @"v1";
        -:   15:
        -:   16:
        -:   17:@implementation FSKConnection
        -:   18:NSString *userAgentString = @"test";
        -:   19:
        6:   20:- (id)init {
        6:   21:	self = [super init]; 
        -:   22:
        6:   23:	[self setConnectionTimeoutInterval:5.0];
        6:   24:	userAgentString = [[NSString stringWithFormat:@"%@/%@", FSKitAgent, FSKitVersion] retain];
        6:   25:	responseDataCache = [[[NSMutableDictionary alloc] init] retain];
        6:   26:	return self;
        -:   27:}
        -:   28:
        -:   29:- (void) dealloc
        6:   30:{
        6:   31:	[credential release];
        6:   32:	[userAgentString release];
        6:   33:	[responseDataCache release];
        6:   34:	[super dealloc];
        -:   35:}
        -:   36:
        -:   37:
        -:   38:/*!
        -:   39:    @method     
        -:   40:    @abstract   Makes a request to a FamilySearch REST API with the provided parameters
        -:   41:    @discussion Uses a URL of the following format <baseURL>/<endpoint>/<version>/<module>/<path>?<parameter1=value1>&<parameter2=value2>
        -:   42:	where the parameters and values are key-value pairs in the provided parameter dictionary
        -:   43:*/
        -:   44://-(void)fetchFamilySearchDataAtEndpoint:(NSString *)endpoint 
        -:   45://							 WithIds:(NSSet *)idList
        -:   46://						  parameters:(NSDictionary *)dict
        -:   47://{
        -:   48://	NSLog(@"%s %@ %@ %@", __PRETTY_FUNCTION__, endpoint, idList, dict);
        -:   49://	if (!dict)
        -:   50://	{
        -:   51://		dict = [[[NSMutableDictionary alloc] init] autorelease];
        -:   52://	}
        -:   53://	[dict setValue:[self sessionId] forKey:@"sessionId"];
        -:   54://	NSString *queryString = @"";
        -:   55://	if (dict && [dict count] > 0)
        -:   56://	{
        -:   57://		queryString = [NSString stringWithFormat:@"?%@", [dict webFormEncoded]];
        -:   58://	}
        -:   59://	NSString *urlString = [NSString stringWithFormat:@"%@/%@/%@%@", FSAPIServerUrlString, endpoint, [[idList allObjects] componentsJoinedByString:@","], queryString];
        -:   60://	
        -:   61://	NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:urlString] 
        -:   62://											 cachePolicy:NSURLRequestReloadIgnoringCacheData 
        -:   63://										 timeoutInterval:[self connectionTimeoutInterval]];
        -:   64://	
        -:   65://	[responseDataCache setObject:[[NSMutableData alloc] init] forKey:[[NSURLConnection connectionWithRequest:request
        -:   66://								  delegate:self] description]];
        -:   67://}
        -:   68:
        -:   69:
        -:   70://	return [self fetchFamilySearchData:[NSURL URLWithString:urlString]];
        -:   71://}
        -:   72:
        -:   73://-(id)fetchFamilySearchData:(NSURL *)theURL
        -:   74://{
        -:   75://	NSLog(@"%s %@", __PRETTY_FUNCTION__, theURL);
        -:   76://	NSMutableURLRequest *urlRequest = [NSMutableURLRequest requestWithURL:theURL 
        -:   77://												cachePolicy:NSURLRequestReloadIgnoringCacheData
        -:   78://											timeoutInterval:[self connectionTimeoutInterval]];
        -:   79://	[urlRequest addValue:[self userAgentString]	forHTTPHeaderField:@"User-Agent"];
        -:   80://	NSHTTPURLResponse *xmlResponse;  //not used right now
        -:   81://	NSError *fetchError; //also not used
        -:   82://	NSData *responseData = [NSURLConnection sendSynchronousRequest:urlRequest
        -:   83://												 returningResponse:&xmlResponse
        -:   84://															 error:&fetchError];
        -:   85://	NSLog(@"\nresponse(%d): %@\nheaders:%@\nerror: %@\ndata:%@", [xmlResponse statusCode], [xmlResponse URL], [xmlResponse allHeaderFields], fetchError, [[NSString alloc] initWithData:responseData encoding:NSUTF8StringEncoding]);
        -:   86://	NSXMLDocument *returnXML = [[NSXMLDocument alloc] initWithData:responseData
        -:   87://														   options:nil
        -:   88://															 error:nil];
        -:   89://	return [returnXML autorelease];
        -:   90://	
        -:   91://	
        -:   92://}
        -:   93:
        -:   94://-(id)postFamilySearchData:(NSURL *)theURL withData:(NSData *)theData ofType:(NSString *)contentType
        -:   95://{
        -:   96://	NSLog(@"%s, %@", __PRETTY_FUNCTION__, theURL);
        -:   97://	NSMutableURLRequest *urlRequest = [NSMutableURLRequest requestWithURL:theURL 
        -:   98://												cachePolicy:NSURLRequestReloadIgnoringCacheData
        -:   99://											timeoutInterval:[self connectionTimeoutInterval]];
        -:  100://	[urlRequest setHTTPMethod:@"POST"];
        -:  101://	[urlRequest setHTTPBody:theData];
        -:  102://	[urlRequest addValue:[self userAgentString]	forHTTPHeaderField:@"User-Agent"];
        -:  103://	if (contentType) {
        -:  104://		[urlRequest setValue:contentType forHTTPHeaderField:@"Content-Type"];
        -:  105://	}
        -:  106://	NSLog(@"request headers: %@", [urlRequest allHTTPHeaderFields]);
        -:  107://	NSHTTPURLResponse *xmlResponse;  //not used right now
        -:  108://	NSError *fetchError; //also not used
        -:  109://	NSData *responseData = [NSURLConnection sendSynchronousRequest:urlRequest
        -:  110://												 returningResponse:&xmlResponse
        -:  111://															 error:&fetchError];
        -:  112://	NSLog(@"\nresponse(%d): %@\nheaders:%@\nerror: %@\ndata:%@", [xmlResponse statusCode], [xmlResponse URL], [xmlResponse allHeaderFields], fetchError, [[NSString alloc] initWithData:responseData encoding:NSUTF8StringEncoding]);
        -:  113://	NSXMLDocument *returnXML = [[NSXMLDocument alloc] initWithData:responseData
        -:  114://														   options:nil
        -:  115://															 error:nil];
        -:  116://	return [returnXML autorelease];
        -:  117://}
        -:  118:
       12:  119:- (NSURLCredential *)credential {
       12:  120:    return [[credential retain] autorelease];
        -:  121:}
        -:  122:
    #####:  123:- (void)setCredential:(NSURLCredential *)value {
    #####:  124:    if (credential != value) {
    #####:  125:        [credential release];
    #####:  126:        credential = [value copy];
        -:  127:    }
        -:  128:}
        -:  129:
    #####:  130:- (NSString *)developerKey {
    #####:  131:    return [[developerKey retain] autorelease];
        -:  132:}
        -:  133:
    #####:  134:- (void)setDeveloperKey:(NSString *)value {
    #####:  135:    if (developerKey != value) {
    #####:  136:        [developerKey release];
    #####:  137:        developerKey = [value copy];
        -:  138:    }
        -:  139:}
        -:  140:
    #####:  141:- (NSString *)sessionId {
    #####:  142:    return [[_sessionId retain] autorelease];
        -:  143:}
        -:  144:
    #####:  145:- (void)setSessionId:(NSString *)value {
    #####:  146:    if (_sessionId != value) {
    #####:  147:        [_sessionId release];
    #####:  148:        _sessionId = [value copy];
        -:  149:    }
        -:  150:}
        -:  151:
        -:  152:- (BOOL)hasSessionId
    #####:  153:{
    #####:  154:	return (_sessionId && [_sessionId length] > 0);
        -:  155:}
        -:  156:
        -:  157:- (BOOL)needsAuthentication
    #####:  158:{
    #####:  159:    return needsAuthentication;
        -:  160:}
        -:  161:
        -:  162:- (void)setNeedsAuthentication:(BOOL)value
    #####:  163:{
    #####:  164:    if (needsAuthentication != value)
        -:  165:	{
    #####:  166:        needsAuthentication = value;
        -:  167:    }
        -:  168:}
        -:  169:
        -:  170:-(void)setConnectionTimeoutInterval:(double)aConnectionTimeoutInterval
        6:  171:{
        6:  172:	connectionTimeoutInterval = aConnectionTimeoutInterval;
        -:  173:}
        -:  174:
        -:  175:-(NSTimeInterval)connectionTimeoutInterval
    #####:  176:{
    #####:  177:	return connectionTimeoutInterval;
        -:  178:}
        -:  179:
    #####:  180:- (void)setUserAgentString:(NSString *)newAgentString override:(BOOL)override {
    #####:  181:	if (newAgentString == nil) {
    #####:  182:		newAgentString = @"";
        -:  183:	}
    #####:  184:	if (override) {
    #####:  185:		userAgentString = [@"" stringByAppendingString:newAgentString];
        -:  186:	} else {
    #####:  187:		userAgentString = [[newAgentString stringByAppendingFormat:@" %@/%@", FSKitAgent, FSKitVersion] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        -:  188:	}
        -:  189:}
        -:  190:
    #####:  191:- (NSString *)userAgentString {
    #####:  192:	return userAgentString;
        -:  193:}
        -:  194:
    #####:  195:- (id)delegate {
    #####:  196:    return [[_delegate retain] autorelease];
        -:  197:}
        -:  198:
    #####:  199:- (void)setDelegate:(id)value {
    #####:  200:	_delegate = value;
        -:  201:}
        -:  202:
        -:  203:
        -:  204:@end
        -:  205:
        -:  206:@implementation FSKConnection(PrivateMethods)
        -:  207:
        -:  208:-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data
    #####:  209:{
    #####:  210:	NSLog(@"%s %@", __PRETTY_FUNCTION__, data);
    #####:  211:	[[responseDataCache objectForKey:[connection description]] appendData:data];
        -:  212:}
        -:  213:
        -:  214:-(void)connectionDidFinishLoading:(NSURLConnection *)connection
    #####:  215:{	
    #####:  216:	NSLog(@"%s %@", __PRETTY_FUNCTION__, connection);
        -:  217:	NSXMLDocument *returnXML = [[NSXMLDocument alloc] initWithData:[responseDataCache objectForKey:[connection description]]
        -:  218:														   options:nil
    #####:  219:															 error:nil];
    #####:  220:    SEL _selector = @selector(requestFinished:);																	
    #####:  221:	if([_delegate respondsToSelector:_selector])
    #####:  222:		[_delegate performSelector:_selector withObject:returnXML];
        -:  223:
    #####:  224:   [self release];
        -:  225:}
        -:  226:
        -:  227://0.6 suggestion to pass connection error.  Thanks Adam.
        -:  228:- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error
    #####:  229:{
    #####:  230:	NSLog(@"%s %@", __PRETTY_FUNCTION__, error);
    #####:  231:	if([_delegate respondsToSelector:@selector(asyncRequestFailed:)])
    #####:  232:		[_delegate performSelector:@selector(asyncRequestFailed:) withObject:error];
        -:  233:}
        -:  234:
        -:  235:
        -:  236:
        -:  237:@end
        -:  238:
        -:  239:@implementation NSString(NSStringExtras)
        -:  240:/*
        -:  241:	Encode a string legally so it can be turned into an NSURL
        -:  242:	Original Source: <http://cocoa.karelia.com/Foundation_Categories/NSString/Encode_a_string_leg.m>
        -:  243:	(See copyright notice at <http://cocoa.karelia.com>)
        -:  244:	 */
        -:  245:
        -:  246:/*"	Fix a URL-encoded string that may have some characters that makes NSURL barf.
        -:  247:It basicaly re-encodes the string, but ignores escape characters + and %, and also #.
        -:  248:"*/
        -:  249:- (NSString *) encodeURLLegally
    #####:  250:{
        -:  251:	NSString *result = (NSString *) CFURLCreateStringByAddingPercentEscapes(NULL, (CFStringRef) self, (CFStringRef) @"%+#", NULL,
    #####:  252:																			CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding));
    #####:  253:	return result;
        -:  254:}
        -:  255:@end
        -:  256:
        -:  257:@implementation NSDictionary(webFormEncoded)
        -:  258:/*
        -:  259:Return the key-value pairs in the dictionary, with the keys and values encoded as query parameters, 
        -:  260:paired by =, and delimited with &. This is the format for a full set of named parameters in a 
        -:  261:URL-coded query.
        -:  262:Original Source: <http://www.mactech.com/articles/mactech/Vol.19/19.03/HTTPMessages/index.html>
        -:  263:modified to handle multi-valued keys like view=summary&view=values....
        -:  264:*/
        -:  265:- (NSString *) webFormEncoded
    #####:  266:{
    #####:  267:	NSEnumerator *      keys = [self keyEnumerator];
        -:  268:	NSString *            currKey;
        -:  269:	NSString *            currObject;
        -:  270:	NSMutableString *   retval = [NSMutableString
    #####:  271:								  stringWithCapacity: 256];
    #####:  272:	BOOL                     started = NO;
    #####:  273:	while ((currKey = [keys nextObject]) != nil)
        -:  274:	{
        -:  275:		//   Chain the key-value pairs, properly escaped, in one string.
    #####:  276:		if (started)
    #####:  277:			[retval appendString: @"&"];
        -:  278:		else
    #####:  279:			started = YES;
        -:  280:		
    #####:  281:		currKey = [currKey encodeURLLegally];
        -:  282:		
        -:  283:		// modified to handle multi-valued keys as arrays of NSString
    #####:  284:		if ( [[self objectForKey: currKey] isKindOfClass:[NSArray class]] )
        -:  285:		{
    #####:  286:			NSArray *currList = [self objectForKey: currKey];
    #####:  287:			int i = 0;
    #####:  288:			for ( i = 0 ; i < [currList count] ; i++ )
        -:  289:			{
    #####:  290:				if (i > 0) [retval appendString:@"&"];
    #####:  291:				currObject = [[currList objectAtIndex:i] encodeURLLegally];
    #####:  292:				[retval appendString: [NSString stringWithFormat:@"%@=%@", currKey, currObject]];
        -:  293:			}
        -:  294:		}
        -:  295:		else
        -:  296:		{
    #####:  297:			currObject = [[self objectForKey: currKey] encodeURLLegally];
    #####:  298:			[retval appendString: [NSString stringWithFormat:@"%@=%@", currKey, currObject]];
        -:  299:		}
        -:  300:	}
    #####:  301:	return retval;
        -:  302:}
        -:  303:@end
