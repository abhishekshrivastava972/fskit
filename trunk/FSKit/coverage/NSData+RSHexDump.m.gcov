        -:    0:Source:/Users/logan/Projects/FSKit/Source/NSData+RSHexDump/NSData+RSHexDump.m
        -:    0:Graph:/Users/logan/Projects/builds/FSKit.build/Coverage/FSKit.build/Objects-normal/ppc/NSData+RSHexDump.gcno
        -:    0:Data:/Users/logan/Projects/builds/FSKit.build/Coverage/FSKit.build/Objects-normal/ppc/NSData+RSHexDump.gcda
        -:    0:Runs:6
        -:    0:Programs:1
        -:    1://
        -:    2://  NSData+RSHexDump.m
        -:    3://  RSFoundation
        -:    4://
        -:    5://  Created by Daniel Jalkut on 2/14/07.
        -:    6://  Copyright 2007 Red Sweater Software. All rights reserved.
        -:    7://
        -:    8://	Based on code from Dan Wood 
        -:    9://	http://gigliwood.com/weblog/Cocoa/Better_description_.html
        -:   10://
        -:   11://
        -:   12:
        -:   13:#import "NSData+RSHexDump.h"
        -:   14:
        -:   15:const unsigned int kDefaultMaxBytesToHexDump = 1024;
        -:   16:
        -:   17:@implementation NSData ( RSHexDump )
        -:   18:
        -:   19:- (NSString *)description
    #####:   20:{
    #####:   21:	return [self descriptionFromOffset:0];
        -:   22:}
        -:   23:
        -:   24:- (NSString *)descriptionFromOffset:(int)startOffset
    #####:   25:{
    #####:   26:	return [self descriptionFromOffset:startOffset limitingToByteCount:kDefaultMaxBytesToHexDump];
        -:   27:}
        -:   28:
        -:   29:- (NSString *)descriptionFromOffset:(int)startOffset limitingToByteCount:(unsigned int)maxBytes
    #####:   30:{
    #####:   31:    unsigned char *bytes = (unsigned char *)[self bytes];
    #####:   32:    unsigned int stopOffset = [self length];
        -:   33:
        -:   34:	// Translate negative offset to positive, by subtracting from end
    #####:   35:	if (startOffset < 0)
        -:   36:	{
    #####:   37:		startOffset = [self length] + startOffset;
        -:   38:	}
        -:   39:
        -:   40:	// Do we have more data than the caller wants?
    #####:   41:	BOOL curtailOutput = NO;
    #####:   42:	if ((stopOffset - startOffset) > maxBytes)
        -:   43:	{
    #####:   44:		curtailOutput = YES;
    #####:   45:		stopOffset = startOffset + maxBytes;
        -:   46:	}
        -:   47:
        -:   48:	// If we're showing a subset, we'll tack in info about that
    #####:   49:	NSString* curtailInfo = @"";
    #####:   50:	if ((startOffset > 0) || (stopOffset < [self length]))
        -:   51:	{
    #####:   52:		curtailInfo = [NSString stringWithFormat:@" (showing bytes %d through %d)", startOffset, stopOffset];
        -:   53:	}
        -:   54:	
        -:   55:	// Start the hexdump out with an overview of the content
    #####:   56:	NSMutableString *buf = [NSMutableString stringWithFormat:@"NSData %d bytes%@:\n", [self length], curtailInfo];
        -:   57:	
        -:   58:	// One row of 16-bytes at a time ...
        -:   59:    int i, j;
    #####:   60:    for ( i = startOffset ; i < stopOffset ; i += 16 )
        -:   61:    {
        -:   62:		// Show the row in Hex first
    #####:   63:        for ( j = 0 ; j < 16 ; j++ )    
        -:   64:        {
    #####:   65:            int rowOffset = i+j;
    #####:   66:            if (rowOffset < stopOffset)
        -:   67:            {
    #####:   68:                [buf appendFormat:@"%02X ", bytes[rowOffset]];
        -:   69:            }
        -:   70:            else
        -:   71:            {
    #####:   72:                [buf appendFormat:@"   "];
        -:   73:            }
        -:   74:        }
        -:   75:		
        -:   76:		// Now show in ASCII
    #####:   77:        [buf appendString:@"| "];   
    #####:   78:        for ( j = 0 ; j < 16 ; j++ )
        -:   79:        {
    #####:   80:            int rowOffset = i+j;
    #####:   81:            if (rowOffset < stopOffset)
        -:   82:            {
    #####:   83:                unsigned char theChar = bytes[rowOffset];
    #####:   84:                if (theChar < 32 || theChar > 127)
        -:   85:                {
    #####:   86:                    theChar ='.';
        -:   87:                }
    #####:   88:                [buf appendFormat:@"%c", theChar];
        -:   89:            }
        -:   90:        }
        -:   91:		
        -:   92:		// If we're not on the last row, tack on a newline
    #####:   93:		if (i+16 < stopOffset)
        -:   94:		{
    #####:   95:			[buf appendString:@"\n"];
        -:   96:		}
        -:   97:	}
        -:   98:	
    #####:   99:    return buf;	
        -:  100:}
        -:  101:
        -:  102:@end
